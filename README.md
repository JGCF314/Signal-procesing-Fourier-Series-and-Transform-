# Signal-procesing-Fourier-Series-and-Transform-
"""Series y transformada de Fourier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13BABMgcWYmEQdMv-WiZlgBoAIkgvZEnV
"""

#Análisis del error
def error(vr,vo):
  er=abs((vr-vo)/vr)
  return er

import matplotlib.pyplot as plt
#Representación gráfica del error
def GrError(x,y,li,ls):
  plt.plot(x,y)
  plt.ylabel("$error$")
  plt.xlim(li,ls)
  plt.title("Error")
  plt.savefig("Error.png")
  plt.show()

import numpy as np
#Integración por la recta de Simpson
def Simpson(f, a, b, n):
  h=(b-a)/n
  I=h/3 * (f[0] + 4*np.sum(f[1:-1:2])+2*np.sum(f[2:-1:2])+f[-1])
  return I
#Integración por la regla del trapezoide compuesta
def trapezC(f, a, b, N):
    h = (b - a)/N
    s = (f(a) + f(b))/2
    for k in range(1,N):
      s += f(a + k*h)
    I = s*h
    return I

import matplotlib.pyplot as plt
#Representación gráfica de señales en series de Fourier
def GrFourier(x,y,z,li,ls):
  plt.plot(x,y)
  plt.plot(x,z)
  plt.xlabel("$t$")
  plt.ylabel("$x(t)$")
  plt.xlim(li,ls)
  plt.title("Representación en series de Fourier")
  plt.savefig("Fourier.png")
  plt.show()

#Series de Fourier (método recta de Simpson)
def SFourierS(x,li,ls,tmuestra,nter):
  T=ls-li
  r=nter/tmuestra
  a0=1/T*Simpson(x,li,ls,nter)*r
  Bk=lambda n:2/T*(Simpson(x*np.cos(2.*np.pi*n*t/T),li,ls,nter))*r
  Ck=lambda n:2/T*(Simpson(x*np.sin(2.*np.pi*n*t/T),li,ls,nter))*r
  SF=a0+sum([Bk(n)*np.cos(2.*np.pi*n*t/T)+Ck(n)*np.sin(2.*np.pi*n*t/T) for n in range(1,nter)])
  return SF

#Series de Fourier (método regla del trapezoide compuesta)
def SFourierTC(x,li,ls,tmuestra,nter):
  T=ls-li
  tmp=np.linspace(li,ls,tmuestra)
  a0=1/T*trapezC(x,li,ls,tmuestra)
  Bk=lambda n:2/T*(trapezC(lambda t: x(t)*np.cos(2.*np.pi*n*t/T),li,ls,tmuestra))
  Ck=lambda n:2/T*(trapezC(lambda t: x(t)*np.sin(2.*np.pi*n*t/T),li,ls,tmuestra))
  SF=a0+sum([Bk(n)*np.cos(2.*np.pi*n*tmp/T)+Ck(n)*np.sin(2.*np.pi*n*tmp/T) for n in range(1,nter)])
  return SF

#Series de Fourier (Implementación directa)
from scipy.integrate import simps
def SFourier(x,li,ls,tmuestra,nter):
  T=ls-li
  a0=1/T*simps(x,t)
  Bk=lambda n:2/T*simps(x*np.cos(2.*np.pi*n*t/T),t)
  Ck=lambda n:2/T*simps(x*np.sin(2.*np.pi*n*t/T),t)
  SF=a0+sum([Bk(n)*np.cos(2.*np.pi*n*t/T)+Ck(n)*np.sin(2.*np.pi*n*t/T) for n in range(1,nter)])
  return SF

#Serie de Fourier señal cuadrada
from scipy.signal import square
li=-9
ls=9
fr=4
tmuestra=2000
nter=100
t=np.linspace(li,ls,tmuestra)
x=square(2.0*np.pi*t*fr/(li-ls))
xt=lambda t: square(2.0*np.pi*t*fr/(li-ls))
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Implementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Serie de Fourier señal diente de sierra
from scipy.signal import sawtooth
li=-5
ls=5
fr=9
tmuestra=2000
nter=100
t=np.linspace(li,ls,tmuestra)
x=sawtooth(2.0*np.pi*t*fr/(li-ls))
xt=lambda t: sawtooth(2.0*np.pi*t*fr/(li-ls))
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Impplementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Serie de Fourier señal cosenoidal
from scipy.signal import sawtooth
li=-2
ls=2
fr=4
tmuestra=1000
nter=100
t=np.linspace(li,ls,tmuestra)
x=np.cos(fr*t)
xt=lambda t: np.cos(fr*t)
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Impplementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Serie de Fourier señal senoidal
from scipy.signal import sawtooth
li=-7
ls=7
fr=6
tmuestra=500
nter=100
t=np.linspace(li,ls,tmuestra)
x=np.sin(fr*t)
xt=lambda t: np.sin(fr*t)
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Impplementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Serie de Fourier señal exponencial
from scipy.signal import sawtooth
li=-1
ls=1
fr=2
tmuestra=1000
nter=100
t=np.linspace(li,ls,tmuestra)
x=np.e**(fr*t)
xt=lambda t: np.e**(fr*t)
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Impplementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Serie de Fourier señal triangular
from scipy.signal import triang
li=-5
ls=5
tmuestra=500
nter=100
t=np.linspace(li,ls,tmuestra)
x=triang(tmuestra)
xt=lambda t: triang(tmuestra)
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Impplementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Serie de Fourier señal senoidal hiperbólica
li=-5
ls=5
fr=7
tmuestra=1000
nter=500
t=np.linspace(li,ls,tmuestra)
x=np.sinh(fr*t)
xt=lambda t: np.sinh(fr*t)
#Simpson
SFS=SFourierS(x,li,ls,tmuestra,nter)
GrFourier(t,SFS,x,li,ls)
#Trapezoide Compuesto
SFT=SFourierTC(xt,li,ls,tmuestra,nter)
GrFourier(t,SFT,x,li,ls)
#Impplementacion directa
SF=SFourier(x,li,ls,tmuestra,nter)
GrFourier(t,SF,x,li,ls)
#Error
er=error(SF,SFS)
GrError(t,er,li,ls)

#Resolución de EDO con valores iniciales (método de Runge Kutta de cuarto orden)
def rungekutta(R,L,x,t0,y0,tn,n):
  def dtdy(t,y):
    return (R/L)*(x(t)-y)
  h = (tn-t0)/n
  for i in range(n):
      k1 = h * (dtdy(t0, y0))
      k2 = h * (dtdy((t0+h/2), (y0+k1/2)))
      k3 = h * (dtdy((t0+h/2), (y0+k2/2)))
      k4 = h * (dtdy((t0+h), (y0+k3)))
      k = (k1+2*k2+2*k3+k4)/6
      yn = y0 + k
      y0 = yn
      t0 = t0+h
      return yn

#Representación gráfica de señales de salida de un sistema en el tiempo
def GrSalida(x,y,li,ls):
  plt.plot(x,y)
  plt.xlabel("$t$")
  plt.ylabel("$y(t)$")
  plt.xlim(li,ls)
  plt.title("Señal de salida (tiempo)")
  plt.savefig("y.png")
  plt.show()

from scipy.fft import fft
#Transformada de Fourier (método de Cooley-Tukey)
def CooleyTukeyTF(x):
  N=len(x)
  X=0
  if N == 1:
    X=x
  else:
    EX=CooleyTukeyTF(x[::2])
    OX=CooleyTukeyTF(x[1::2])
    f=np.exp(-2j*np.pi*np.arange(N)/N)
    M=int(N/2)
    X=np.concatenate([EX+f[:M]*OX,EX+f[M:]*OX])
  return X

#Representación gráfica de señales de respuesta al impulso en frecuencia
def TransformF(x,y,li,ls):
  X1=CooleyTukeyTF(x)
  #Implementación directa
  X2=fft(x)
  Y=CooleyTukeyTF(y)
  Ho=Y/X1
  Hr=Y/X2
  Reo=Ho.real
  Rer=Hr.real
  Imo=Ho.imag
  Imr=Hr.imag
  N=len(Ho)
  ω=np.arange(N)
  Modoω=(Reo**2+Imo**2)**(1/2)
  Modrω=(Rer**2+Imr**2)**(1/2)
  plt.plot(ω,Modoω)
  plt.plot(ω,Modrω)
  plt.xlabel("$ω$")
  plt.ylabel("$|H(jω)|$")
  plt.xlim(li,ls)
  plt.title("Espectro de respuesta al impulso (frecuencia)")
  plt.savefig("H.png")
  plt.show()
  #Error
  er=error(Modrω,Modoω)
  GrError(ω,er,li,ls)

#Sistema con señal de entrada senoidal
R=33
L=7
xs=lambda t:np.sin(t)
t0=0
y0=0
n=20
li=0
ls=20
t=np.linspace(li,ls,512)
x=np.sin(t)
y=rungekutta(R,L,xs,t0,y0,t,n)
GrSalida(t,y,li,ls)
TransformF(x,y,li,ls)

#Sistema con señal de entrada cosenoidal
R=33
L=7
xs=lambda t:np.cos(t)
t0=0
y0=0
n=20
li=0
ls=100
t=np.linspace(li,ls,1024)
x=np.cos(t)
y=rungekutta(R,L,xs,t0,y0,t,n)
GrSalida(t,y,li,ls)
TransformF(x,y,li,ls)

#Sistema con señal de entrada cuadrada
R=10
L=3
li=0
ls=50
fr=1
xs=lambda t: square(2.0*np.pi*t*fr/(li-ls))
t0=0
y0=0
n=500
t=np.linspace(li,ls,1024)
x=square(2.0*np.pi*t*fr/(li-ls))
y=rungekutta(R,L,xs,t0,y0,t,n)
GrSalida(t,y,li,ls)
TransformF(x,y,li,ls)

#Sistema con señal de entrada diente de sierra
R=10
L=3
li=0
ls=20
fr=2
xs=lambda t: sawtooth(2.0*np.pi*t*fr/(li-ls))
t0=0
y0=0
n=500
t=np.linspace(li,ls,1024)
x=sawtooth(2.0*np.pi*t*fr/(li-ls))
y=rungekutta(R,L,xs,t0,y0,t,n)
GrSalida(t,y,li,ls)
TransformF(x,y,li,ls)

#Sistema con señal de entrada senoidal hiperbólica
R=22
L=1
xs=lambda t:np.sinh(t)
t0=0
y0=0
n=20
li=0
ls=20
t=np.linspace(li,ls,512)
x=np.sinh(t)
y=rungekutta(R,L,xs,t0,y0,t,n)
GrSalida(t,y,li,ls)
TransformF(x,y,li,ls)

#Sistema con señal de entrada exponencial
R=18
L=3
xs=lambda t:np.e**t
t0=0
y0=0
n=20
li=0
ls=20
t=np.linspace(li,ls,512)
x=np.e**t
y=rungekutta(R,L,xs,t0,y0,t,n)
GrSalida(t,y,li,ls)
TransformF(x,y,li,ls)
